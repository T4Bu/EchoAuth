
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">EchoAuth/cmd/main.go (0.0%)</option>
				
				<option value="file1">EchoAuth/config/config.go (100.0%)</option>
				
				<option value="file2">EchoAuth/middlewares/auth_middleware.go (88.2%)</option>
				
				<option value="file3">EchoAuth/middlewares/logger.go (95.5%)</option>
				
				<option value="file4">EchoAuth/middlewares/rate_limit.go (100.0%)</option>
				
				<option value="file5">EchoAuth/middlewares/rate_limiter.go (84.6%)</option>
				
				<option value="file6">EchoAuth/middlewares/security.go (97.0%)</option>
				
				<option value="file7">EchoAuth/models/claims.go (100.0%)</option>
				
				<option value="file8">EchoAuth/models/token.go (100.0%)</option>
				
				<option value="file9">EchoAuth/models/user.go (91.7%)</option>
				
				<option value="file10">EchoAuth/repositories/token_repository.go (82.4%)</option>
				
				<option value="file11">EchoAuth/repositories/user_repository.go (67.9%)</option>
				
				<option value="file12">EchoAuth/services/account_lockout.go (84.1%)</option>
				
				<option value="file13">EchoAuth/services/auth_service.go (73.3%)</option>
				
				<option value="file14">EchoAuth/services/email_service.go (92.3%)</option>
				
				<option value="file15">EchoAuth/services/password_reset_service.go (88.9%)</option>
				
				<option value="file16">EchoAuth/services/rate_limiter.go (90.9%)</option>
				
				<option value="file17">EchoAuth/utils/logger/logger.go (72.7%)</option>
				
				<option value="file18">EchoAuth/utils/metrics/metrics.go (95.2%)</option>
				
				<option value="file19">EchoAuth/utils/response/json.go (100.0%)</option>
				
				<option value="file20">EchoAuth/utils/validator/email.go (100.0%)</option>
				
				<option value="file21">EchoAuth/utils/validator/password.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "EchoAuth/config"
        "EchoAuth/controllers"
        "EchoAuth/database"
        "EchoAuth/middlewares"
        "EchoAuth/repositories"
        "EchoAuth/services"
        "EchoAuth/utils/logger"
        "context"
        "net/http"
        "os"
        "os/signal"
        "path/filepath"
        "syscall"
        "time"

        "github.com/gorilla/mux"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/redis/go-redis/v9"
        "github.com/rs/zerolog"
)

// Dependencies holds all service dependencies
type Dependencies struct {
        UserRepo    repositories.UserRepository
        TokenRepo   *repositories.TokenRepository
        LockoutSvc  *services.AccountLockoutService
        AuthService controllers.AuthService
        RedisClient *redis.Client
        DB          *database.DB
}

// NewDependencies creates a new Dependencies instance
func NewDependencies(db *database.DB, redisClient *redis.Client, cfg *config.Config) *Dependencies <span class="cov0" title="0">{
        userRepo := repositories.NewUserRepository(db)
        tokenRepo := repositories.NewTokenRepository(db)
        lockoutSvc := services.NewAccountLockoutService(redisClient)
        authService := services.NewAuthService(userRepo, tokenRepo, cfg, lockoutSvc)

        return &amp;Dependencies{
                UserRepo:    userRepo,
                TokenRepo:   tokenRepo,
                LockoutSvc:  lockoutSvc,
                AuthService: authService,
                RedisClient: redisClient,
                DB:          db,
        }
}</span>

func initLogger() zerolog.Logger <span class="cov0" title="0">{
        logger.Init()
        return logger.GetLogger("main")
}</span>

func initDatabase(cfg *config.Config, log zerolog.Logger) *database.DB <span class="cov0" title="0">{
        db, err := database.InitDB(cfg.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to initialize database")
        }</span>

        // Apply migrations
        <span class="cov0" title="0">log.Info().Msg("Applying database migrations...")
        migrationsDir := filepath.Join(".", "migrations")
        if err := db.Migrate(migrationsDir); err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to apply database migrations")
        }</span>
        <span class="cov0" title="0">log.Info().Msg("Database migrations applied successfully")

        return db</span>
}

func initRedis(cfg *config.Config, log zerolog.Logger) *redis.Client <span class="cov0" title="0">{
        redisClient := redis.NewClient(&amp;redis.Options{
                Addr:     cfg.Redis.Addr,
                Password: cfg.Redis.Password,
                DB:       cfg.Redis.DB,
        })

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if _, err := redisClient.Ping(ctx).Result(); err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to connect to Redis")
        }</span>
        <span class="cov0" title="0">log.Info().Msg("Connected to Redis successfully")
        return redisClient</span>
}

func setupRouter(deps *Dependencies) *mux.Router <span class="cov0" title="0">{
        healthController := controllers.NewHealthController(deps.DB, deps.RedisClient)
        authController := controllers.NewAuthController(deps.AuthService)

        authMiddleware := middlewares.NewAuthMiddleware(deps.AuthService)
        rateLimiter := middlewares.NewRateLimiter(deps.RedisClient)
        securityConfig := middlewares.NewSecurityConfig()

        router := mux.NewRouter()

        router.Use(rateLimiter.RateLimit)
        router.Use(securityConfig.SecurityMiddleware)

        router.HandleFunc("/health", healthController.Check).Methods("GET")
        router.HandleFunc("/api/EchoAuth/register", authController.Register).Methods("POST")
        router.HandleFunc("/api/EchoAuth/login", authController.Login).Methods("POST")
        router.HandleFunc("/api/EchoAuth/refresh", authController.RefreshToken).Methods("POST")

        protected := router.PathPrefix("/api").Subrouter()
        protected.Use(authMiddleware.Authenticate)
        protected.HandleFunc("/EchoAuth/logout", authController.Logout).Methods("POST")

        router.Handle("/metrics", promhttp.Handler())

        return router
}</span>

func startCleanupRoutine(ctx context.Context, tokenRepo *repositories.TokenRepository, log zerolog.Logger) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(24 * time.Hour)
                defer ticker.Stop()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                if err := tokenRepo.CleanupExpiredTokens(); err != nil </span><span class="cov0" title="0">{
                                        log.Error().Err(err).Msg("Failed to cleanup expired tokens")
                                }</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

func startServer(router *mux.Router, cfg *config.Config, log zerolog.Logger, deps *Dependencies) <span class="cov0" title="0">{
        srv := &amp;http.Server{
                Addr:         ":" + cfg.Port,
                Handler:      router,
                ReadTimeout:  15 * time.Second,
                WriteTimeout: 15 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        // Create context that listens for signals
        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
        defer stop()

        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                log.Info().Str("port", cfg.Port).Msg("Starting server")
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Msg("Server failed to start")
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">&lt;-ctx.Done()
        log.Info().Msg("Shutting down gracefully...")

        // Create shutdown context with timeout
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Attempt graceful shutdown
        if err := srv.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Server forced to shutdown")
        }</span>

        // Close database connection
        <span class="cov0" title="0">if err := deps.DB.Close(); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Error closing database connection")
        }</span>

        // Close Redis connection
        <span class="cov0" title="0">if err := deps.RedisClient.Close(); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Error closing Redis connection")
        }</span>

        <span class="cov0" title="0">log.Info().Msg("Server exited properly")</span>
}

func main() <span class="cov0" title="0">{
        log := initLogger()
        log.Info().Msg("Starting authentication service")

        cfg := config.LoadConfig()
        log.Debug().Interface("config", cfg).Msg("Configuration loaded")

        db := initDatabase(cfg, log)
        redisClient := initRedis(cfg, log)
        deps := NewDependencies(db, redisClient, cfg)

        router := setupRouter(deps)

        // Create context for cleanup routine
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        startCleanupRoutine(ctx, deps.TokenRepo, log)
        startServer(router, cfg, log, deps)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "os"
        "strconv"
        "time"
)

type RedisConfig struct {
        Addr     string
        Password string
        DB       int
}

type Config struct {
        Port        string
        JWTSecret   string
        JWTExpiry   time.Duration
        DatabaseURL string
        Redis       RedisConfig
        Environment string
}

func LoadConfig() *Config <span class="cov4" title="4">{
        jwtExpiry := 24 * time.Hour
        if expStr := getEnv("JWT_EXPIRY", "24h"); expStr != "" </span><span class="cov4" title="4">{
                if exp, err := time.ParseDuration(expStr); err == nil </span><span class="cov3" title="3">{
                        jwtExpiry = exp
                }</span>
        }

        <span class="cov4" title="4">redisDB := 0
        if dbStr := getEnv("REDIS_DB", "0"); dbStr != "" </span><span class="cov4" title="4">{
                if db, err := strconv.Atoi(dbStr); err == nil </span><span class="cov3" title="3">{
                        redisDB = db
                }</span>
        }

        <span class="cov4" title="4">return &amp;Config{
                Port:        getEnv("PORT", "8080"),
                JWTSecret:   getEnv("JWT_SECRET", "your-secret-key"),
                JWTExpiry:   jwtExpiry,
                DatabaseURL: getEnv("DATABASE_URL", "host=localhost user=postgres password=postgres dbname=auth_db port=5432 sslmode=disable"),
                Redis: RedisConfig{
                        Addr:     getEnv("REDIS_ADDR", "localhost:6379"),
                        Password: getEnv("REDIS_PASS", ""),
                        DB:       redisDB,
                },
                Environment: getEnv("ENV", "development"),
        }</span>
}

func getEnv(key, defaultValue string) string <span class="cov10" title="35">{
        if value := os.Getenv(key); value != "" </span><span class="cov7" title="11">{
                return value
        }</span>
        <span class="cov9" title="24">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middlewares

import (
        "EchoAuth/services"
        "EchoAuth/utils/response"
        "context"
        "net/http"
        "strings"
)

type contextKey string

const userIDKey contextKey = "user_id"

type AuthMiddleware struct {
        authService services.AuthServiceInterface
}

func NewAuthMiddleware(authService services.AuthServiceInterface) *AuthMiddleware <span class="cov1" title="1">{
        return &amp;AuthMiddleware{
                authService: authService,
        }
}</span>

func (m *AuthMiddleware) Authenticate(next http.Handler) http.Handler <span class="cov1" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="3">{
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov1" title="1">{
                        response.JSONError(w, "Authorization header required", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov6" title="2">tokenParts := strings.Split(authHeader, " ")
                if len(tokenParts) != 2 || tokenParts[0] != "Bearer" </span><span class="cov0" title="0">{
                        response.JSONError(w, "Invalid authorization header format", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov6" title="2">claims, err := m.authService.ValidateToken(tokenParts[1])
                if err != nil </span><span class="cov1" title="1">{
                        response.JSONError(w, "Invalid token", http.StatusUnauthorized)
                        return
                }</span>

                // Add claims to request context
                <span class="cov1" title="1">ctx := r.Context()
                ctx = context.WithValue(ctx, userIDKey, claims.UserID)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package middlewares

import (
        "EchoAuth/utils/logger"
        "EchoAuth/utils/metrics"
        "net/http"
        "strconv"
        "time"
)

type responseWriter struct {
        http.ResponseWriter
        status      int
        written     int64
        wroteHeader bool
}

func (w *responseWriter) WriteHeader(code int) <span class="cov10" title="7">{
        if !w.wroteHeader </span><span class="cov10" title="7">{
                w.status = code
                w.wroteHeader = true
                w.ResponseWriter.WriteHeader(code)
        }</span>
}

func (w *responseWriter) Write(b []byte) (int, error) <span class="cov9" title="6">{
        if !w.wroteHeader </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusOK)
        }</span>
        <span class="cov9" title="6">n, err := w.ResponseWriter.Write(b)
        w.written += int64(n)
        return n, err</span>
}

func LoggerMiddleware(next http.Handler) http.Handler <span class="cov7" title="4">{
        log := logger.GetLogger("http")

        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov7" title="4">{
                start := time.Now()

                // Create a custom response writer to capture status code
                wrapped := &amp;responseWriter{
                        ResponseWriter: w,
                        status:         200,
                        wroteHeader:    false,
                }

                // Process request
                next.ServeHTTP(wrapped, r)

                // Calculate duration
                duration := time.Since(start)

                // Record metrics
                metrics.RequestDuration.WithLabelValues(
                        r.URL.Path,
                        r.Method,
                        strconv.Itoa(wrapped.status),
                ).Observe(duration.Seconds())

                // Create log event
                event := log.Info().
                        Str("method", r.Method).
                        Str("url", r.URL.String()).
                        Str("path", r.URL.Path).
                        Str("remote_ip", r.RemoteAddr).
                        Int("status", wrapped.status).
                        Int64("size", wrapped.written).
                        Dur("duration", duration)

                // Add request ID if present
                if reqID := r.Header.Get("X-Request-ID"); reqID != "" </span><span class="cov1" title="1">{
                        event.Str("request_id", reqID)
                }</span>

                // Add user ID if authenticated
                <span class="cov7" title="4">if userID := r.Context().Value("user_id"); userID != nil </span><span class="cov0" title="0">{
                        event.Interface("user_id", userID)
                }</span>

                // Log the event
                <span class="cov7" title="4">event.Msg("Request processed")</span>
        })
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package middlewares

import (
        "EchoAuth/services"
        "EchoAuth/utils/metrics"
        "fmt"
        "net/http"
        "strings"
)

func RateLimitMiddleware(limiter services.RateLimiter) func(http.Handler) http.Handler <span class="cov7" title="5">{
        return func(next http.Handler) http.Handler </span><span class="cov7" title="5">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov7" title="5">{
                        // Get IP address
                        ip := getIP(r)

                        // Create rate limit key based on IP and path
                        key := fmt.Sprintf("rate_limit:%s:%s", ip, r.URL.Path)

                        // Check rate limit
                        allowed, err := limiter.Allow(key)
                        if err != nil </span><span class="cov1" title="1">{
                                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov6" title="4">if !allowed </span><span class="cov1" title="1">{
                                // Record rate limit hit
                                metrics.RecordRateLimitHit()
                                http.Error(w, "Too Many Requests", http.StatusTooManyRequests)
                                return
                        }</span>

                        <span class="cov5" title="3">next.ServeHTTP(w, r)</span>
                })
        }
}

// getIP extracts the client IP address from the request
func getIP(r *http.Request) string <span class="cov10" title="11">{
        // Check X-Forwarded-For header
        forwarded := r.Header.Get("X-Forwarded-For")
        if forwarded != "" </span><span class="cov6" title="4">{
                return strings.Split(forwarded, ",")[0]
        }</span>

        // Check X-Real-IP header
        <span class="cov8" title="7">realIP := r.Header.Get("X-Real-IP")
        if realIP != "" </span><span class="cov5" title="3">{
                return realIP
        }</span>

        // Fall back to RemoteAddr
        <span class="cov6" title="4">return strings.Split(r.RemoteAddr, ":")[0]</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package middlewares

import (
        "EchoAuth/services"
        "EchoAuth/utils/response"
        "net/http"
        "time"

        "github.com/redis/go-redis/v9"
)

type RateLimiter struct {
        limiter services.RateLimiter
}

func NewRateLimiter(redisClient *redis.Client) *RateLimiter <span class="cov0" title="0">{
        config := services.RateLimiterConfig{
                MaxAttempts: 100,
                Window:      time.Minute,
        }
        return &amp;RateLimiter{
                limiter: services.NewRateLimiter(redisClient, config),
        }
}</span>

func (rl *RateLimiter) RateLimit(next http.Handler) http.Handler <span class="cov10" title="6">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="6">{
                ip := r.RemoteAddr
                key := "rate_limit:" + ip

                allowed, err := rl.limiter.Allow(key)
                if err != nil </span><span class="cov1" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov9" title="5">if !allowed </span><span class="cov1" title="1">{
                        response.JSONError(w, "Rate limit exceeded", http.StatusTooManyRequests)
                        return
                }</span>

                <span class="cov7" title="4">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middlewares

import (
        "net/http"
        "os"
        "strconv"
        "strings"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/rs/zerolog/log"
)

var (
        corsRequestsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_cors_requests_total",
                        Help: "Total number of CORS requests by origin",
                },
                []string{"origin"},
        )
)

func init() <span class="cov1" title="1">{
        prometheus.MustRegister(corsRequestsTotal)
}</span>

type SecurityConfig struct {
        AllowedOrigins   []string
        AllowedMethods   []string
        AllowedHeaders   []string
        ExposedHeaders   []string
        AllowCredentials bool
        MaxAge           int
        Environment      string
}

func NewSecurityConfig() *SecurityConfig <span class="cov8" title="6">{
        env := os.Getenv("ENV")
        if env == "" </span><span class="cov0" title="0">{
                env = "development"
        }</span>

        <span class="cov8" title="6">config := &amp;SecurityConfig{
                Environment:    env,
                AllowedMethods: []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowedHeaders: []string{
                        "Authorization",
                        "Content-Type",
                        "X-Request-ID",
                        "X-Real-IP",
                },
                ExposedHeaders:   []string{"X-Request-ID"},
                MaxAge:           3600,
                AllowCredentials: true,
        }

        // Set allowed origins based on environment
        if env == "production" </span><span class="cov3" title="2">{
                config.AllowedOrigins = strings.Split(os.Getenv("ALLOWED_ORIGINS"), ",")
                if len(config.AllowedOrigins) == 0 </span><span class="cov0" title="0">{
                        log.Fatal().Msg("ALLOWED_ORIGINS must be set in production")
                }</span>
        } else<span class="cov6" title="4"> {
                config.AllowedOrigins = []string{"http://localhost:3000"}
        }</span>

        <span class="cov8" title="6">return config</span>
}

func (c *SecurityConfig) SecurityMiddleware(next http.Handler) http.Handler <span class="cov8" title="6">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="6">{
                // Security headers first
                w.Header().Set("X-Content-Type-Options", "nosniff")
                w.Header().Set("X-Frame-Options", "DENY")
                w.Header().Set("X-XSS-Protection", "1; mode=block")

                if c.Environment == "production" </span><span class="cov3" title="2">{
                        w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
                }</span>

                <span class="cov8" title="6">origin := r.Header.Get("Origin")

                // CORS headers
                if origin != "" </span><span class="cov8" title="6">{
                        if !c.isAllowedOrigin(origin) </span><span class="cov1" title="1">{
                                log.Warn().
                                        Str("origin", origin).
                                        Str("path", r.URL.Path).
                                        Str("ip", r.RemoteAddr).
                                        Msg("Invalid origin attempt")
                                http.Error(w, "Invalid origin", http.StatusForbidden)
                                return
                        }</span>

                        <span class="cov7" title="5">w.Header().Set("Access-Control-Allow-Origin", origin)
                        w.Header().Set("Access-Control-Allow-Methods", strings.Join(c.AllowedMethods, ", "))
                        w.Header().Set("Access-Control-Allow-Headers", strings.Join(c.AllowedHeaders, ", "))
                        w.Header().Set("Access-Control-Expose-Headers", strings.Join(c.ExposedHeaders, ", "))

                        if c.AllowCredentials </span><span class="cov7" title="5">{
                                w.Header().Set("Access-Control-Allow-Credentials", "true")
                        }</span>

                        // Handle preflight requests
                        <span class="cov7" title="5">if r.Method == "OPTIONS" </span><span class="cov5" title="3">{
                                requestMethod := r.Header.Get("Access-Control-Request-Method")
                                requestHeaders := r.Header.Get("Access-Control-Request-Headers")

                                // Validate requested method
                                methodAllowed := false
                                for _, method := range c.AllowedMethods </span><span class="cov10" title="9">{
                                        if method == requestMethod </span><span class="cov3" title="2">{
                                                methodAllowed = true
                                                break</span>
                                        }
                                }

                                <span class="cov5" title="3">if !methodAllowed </span><span class="cov1" title="1">{
                                        log.Warn().
                                                Str("origin", origin).
                                                Str("method", requestMethod).
                                                Msg("Invalid preflight method request")
                                        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                                        return
                                }</span>

                                // Validate requested headers
                                <span class="cov3" title="2">if requestHeaders != "" </span><span class="cov3" title="2">{
                                        headers := strings.Split(strings.ToLower(requestHeaders), ",")
                                        for _, header := range headers </span><span class="cov5" title="3">{
                                                header = strings.TrimSpace(header)
                                                headerAllowed := false
                                                for _, allowed := range c.AllowedHeaders </span><span class="cov8" title="7">{
                                                        if strings.ToLower(allowed) == header </span><span class="cov3" title="2">{
                                                                headerAllowed = true
                                                                break</span>
                                                        }
                                                }
                                                <span class="cov5" title="3">if !headerAllowed </span><span class="cov1" title="1">{
                                                        log.Warn().
                                                                Str("origin", origin).
                                                                Str("header", header).
                                                                Msg("Invalid preflight header request")
                                                        http.Error(w, "Header not allowed", http.StatusForbidden)
                                                        return
                                                }</span>
                                        }
                                }

                                <span class="cov1" title="1">log.Debug().
                                        Str("origin", origin).
                                        Str("method", requestMethod).
                                        Str("headers", requestHeaders).
                                        Msg("Successful preflight request")

                                w.Header().Set("Access-Control-Max-Age", strconv.Itoa(c.MaxAge))
                                w.WriteHeader(http.StatusOK)
                                return</span>
                        }
                }

                // Metrics
                <span class="cov3" title="2">if origin != "" </span><span class="cov3" title="2">{
                        corsRequestsTotal.WithLabelValues(origin).Inc()
                }</span>

                <span class="cov3" title="2">next.ServeHTTP(w, r)</span>
        })
}

func (c *SecurityConfig) isAllowedOrigin(origin string) bool <span class="cov8" title="6">{
        if c.Environment != "production" </span><span class="cov6" title="4">{
                return true // Allow all origins in non-production environments
        }</span>

        <span class="cov3" title="2">for _, allowed := range c.AllowedOrigins </span><span class="cov5" title="3">{
                if allowed == origin </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package models

import (
        "errors"

        "github.com/golang-jwt/jwt"
)

type TokenClaims struct {
        UserID uint `json:"user_id"`
        jwt.StandardClaims
}

// Valid implements the jwt.Claims interface and adds custom validation
func (c *TokenClaims) Valid() error <span class="cov10" title="8">{
        if err := c.StandardClaims.Valid(); err != nil </span><span class="cov4" title="2">{
                return err
        }</span>

        <span class="cov8" title="6">if c.UserID == 0 </span><span class="cov4" title="2">{
                return errors.New("missing or invalid user ID")
        }</span>

        <span class="cov7" title="4">if c.ExpiresAt == 0 </span><span class="cov1" title="1">{
                return errors.New("missing expiry time")
        }</span>

        <span class="cov5" title="3">if c.IssuedAt == 0 </span><span class="cov1" title="1">{
                return errors.New("missing issued at time")
        }</span>

        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package models

import (
        "time"

        "github.com/google/uuid"
)

type RefreshToken struct {
        ID         uuid.UUID  `json:"id"`
        UserID     uint       `json:"user_id"`
        Token      string     `json:"token"`
        Used       bool       `json:"used"`
        RevokedAt  *time.Time `json:"revoked_at"`
        ExpiresAt  time.Time  `json:"expires_at"`
        CreatedAt  time.Time  `json:"created_at"`
        UpdatedAt  time.Time  `json:"updated_at"`
        PreviousID *uuid.UUID `json:"previous_id"`
        DeviceInfo string     `json:"device_info"`
        IP         string     `json:"ip"`
}

// IsValid checks if the refresh token is still valid
func (rt *RefreshToken) IsValid() bool <span class="cov10" title="5">{
        return !rt.Used &amp;&amp; rt.RevokedAt == nil &amp;&amp; rt.ExpiresAt.After(time.Now())
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package models

import (
        "EchoAuth/utils/validator"
        "time"

        "golang.org/x/crypto/bcrypt"
)

type User struct {
        ID                  uint       `json:"id"`
        Email               string     `json:"email"`
        Password            string     `json:"-"`
        FirstName           string     `json:"first_name"`
        LastName            string     `json:"last_name"`
        PasswordResetToken  string     `json:"-"`
        ResetTokenExpiresAt time.Time  `json:"-"`
        CreatedAt           time.Time  `json:"created_at"`
        UpdatedAt           time.Time  `json:"updated_at"`
        DeletedAt           *time.Time `json:"-"`
}

// HashPassword hashes the provided password and stores it in the user model
func (u *User) HashPassword(password string) error <span class="cov10" title="7">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="7">u.Password = string(hashedPassword)
        return nil</span>
}

// CheckPassword checks if the provided password matches the hashed password
func (u *User) CheckPassword(password string) bool <span class="cov10" title="7">{
        err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
        return err == nil
}</span>

// Validate performs validation on the user model
func (u *User) Validate() error <span class="cov7" title="4">{
        if err := validator.ValidateEmail(u.Email); err != nil </span><span class="cov4" title="2">{
                return err
        }</span>
        <span class="cov4" title="2">if u.Password == "" </span><span class="cov1" title="1">{
                return validator.ErrPasswordTooShort
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package repositories

import (
        "EchoAuth/database"
        "EchoAuth/models"
        "database/sql"
        "time"

        "github.com/google/uuid"
)

type TokenRepositoryInterface interface {
        CreateRefreshToken(userID uint, token string, expiresAt time.Time, deviceInfo, ip string) (*models.RefreshToken, error)
        GetRefreshToken(token string) (*models.RefreshToken, error)
        RotateRefreshToken(currentToken *models.RefreshToken, newToken string, expiresAt time.Time) (*models.RefreshToken, error)
        RevokeRefreshToken(token string) error
        RevokeAllUserTokens(userID uint) error
        CleanupExpiredTokens() error
}

type TokenRepository struct {
        db *database.DB
}

func NewTokenRepository(db *database.DB) *TokenRepository <span class="cov10" title="7">{
        return &amp;TokenRepository{db: db}
}</span>

// CreateRefreshToken creates a new refresh token for a user
func (r *TokenRepository) CreateRefreshToken(userID uint, token string, expiresAt time.Time, deviceInfo, ip string) (*models.RefreshToken, error) <span class="cov1" title="1">{
        refreshToken := &amp;models.RefreshToken{
                ID:         uuid.New(),
                UserID:     userID,
                Token:      token,
                ExpiresAt:  expiresAt,
                DeviceInfo: deviceInfo,
                IP:         ip,
                CreatedAt:  time.Now(),
                UpdatedAt:  time.Now(),
        }

        query := `
                INSERT INTO refresh_tokens (id, user_id, token, expires_at, device_info, ip, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`

        _, err := r.db.Exec(query,
                refreshToken.ID, refreshToken.UserID, refreshToken.Token,
                refreshToken.ExpiresAt, refreshToken.DeviceInfo, refreshToken.IP,
                refreshToken.CreatedAt, refreshToken.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return refreshToken, nil</span>
}

// GetRefreshToken retrieves a refresh token by its token string
func (r *TokenRepository) GetRefreshToken(token string) (*models.RefreshToken, error) <span class="cov4" title="2">{
        refreshToken := &amp;models.RefreshToken{}
        query := `
                SELECT id, user_id, token, used, revoked_at, expires_at, created_at, updated_at,
                        previous_id, device_info, ip
                FROM refresh_tokens
                WHERE token = $1`

        err := r.db.QueryRow(query, token).Scan(
                &amp;refreshToken.ID, &amp;refreshToken.UserID, &amp;refreshToken.Token,
                &amp;refreshToken.Used, &amp;refreshToken.RevokedAt, &amp;refreshToken.ExpiresAt,
                &amp;refreshToken.CreatedAt, &amp;refreshToken.UpdatedAt,
                &amp;refreshToken.PreviousID, &amp;refreshToken.DeviceInfo, &amp;refreshToken.IP)

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                return nil, ErrNotFound
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return refreshToken, nil</span>
}

// RotateRefreshToken marks the current token as used and creates a new one
func (r *TokenRepository) RotateRefreshToken(currentToken *models.RefreshToken, newToken string, expiresAt time.Time) (*models.RefreshToken, error) <span class="cov1" title="1">{
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer tx.Rollback()

        // Mark current token as used
        updateQuery := `
                UPDATE refresh_tokens
                SET used = true, updated_at = $1
                WHERE id = $2`

        now := time.Now()
        _, err = tx.Exec(updateQuery, now, currentToken.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create new token with reference to the previous one
        <span class="cov1" title="1">newRefreshToken := &amp;models.RefreshToken{
                ID:         uuid.New(),
                UserID:     currentToken.UserID,
                Token:      newToken,
                ExpiresAt:  expiresAt,
                PreviousID: &amp;currentToken.ID,
                DeviceInfo: currentToken.DeviceInfo,
                IP:         currentToken.IP,
                CreatedAt:  now,
                UpdatedAt:  now,
        }

        insertQuery := `
                INSERT INTO refresh_tokens (id, user_id, token, expires_at, previous_id, device_info, ip, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`

        _, err = tx.Exec(insertQuery,
                newRefreshToken.ID, newRefreshToken.UserID, newRefreshToken.Token,
                newRefreshToken.ExpiresAt, newRefreshToken.PreviousID,
                newRefreshToken.DeviceInfo, newRefreshToken.IP,
                newRefreshToken.CreatedAt, newRefreshToken.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return newRefreshToken, nil</span>
}

// RevokeRefreshToken marks a refresh token as revoked
func (r *TokenRepository) RevokeRefreshToken(token string) error <span class="cov1" title="1">{
        now := time.Now()
        query := `
                UPDATE refresh_tokens
                SET revoked_at = $1, updated_at = $2
                WHERE token = $3`

        result, err := r.db.Exec(query, now, now, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// RevokeAllUserTokens revokes all refresh tokens for a user
func (r *TokenRepository) RevokeAllUserTokens(userID uint) error <span class="cov1" title="1">{
        now := time.Now()
        query := `
                UPDATE refresh_tokens
                SET revoked_at = $1, updated_at = $2
                WHERE user_id = $3 AND revoked_at IS NULL`

        _, err := r.db.Exec(query, now, now, userID)
        return err
}</span>

// CleanupExpiredTokens removes expired and used tokens
func (r *TokenRepository) CleanupExpiredTokens() error <span class="cov1" title="1">{
        query := `
                DELETE FROM refresh_tokens
                WHERE expires_at &lt; $1 OR used = true`

        _, err := r.db.Exec(query, time.Now())
        return err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package repositories

import (
        "EchoAuth/database"
        "EchoAuth/models"
        "database/sql"
        "errors"
        "time"
)

var (
        ErrNotFound = errors.New("record not found")
)

type UserRepository interface {
        Create(user *models.User) error
        FindByEmail(email string) (*models.User, error)
        FindByID(id uint) (*models.User, error)
        Update(user *models.User) error
        Delete(id uint) error
        FindByResetToken(token string) (*models.User, error)
}

type userRepository struct {
        db *database.DB
}

func NewUserRepository(db *database.DB) UserRepository <span class="cov10" title="6">{
        return &amp;userRepository{
                db: db,
        }
}</span>

func (r *userRepository) Create(user *models.User) error <span class="cov1" title="1">{
        now := time.Now()
        user.CreatedAt = now
        user.UpdatedAt = now

        query := `
                INSERT INTO users (email, password, first_name, last_name, password_reset_token, 
                        reset_token_expires_at, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                RETURNING id`

        err := r.db.QueryRow(query,
                user.Email, user.Password, user.FirstName, user.LastName,
                user.PasswordResetToken, user.ResetTokenExpiresAt,
                user.CreatedAt, user.UpdatedAt).Scan(&amp;user.ID)

        return err
}</span>

func (r *userRepository) FindByEmail(email string) (*models.User, error) <span class="cov4" title="2">{
        user := &amp;models.User{}
        query := `
                SELECT id, email, password, first_name, last_name, password_reset_token,
                        reset_token_expires_at, created_at, updated_at, deleted_at
                FROM users
                WHERE email = $1 AND deleted_at IS NULL`

        err := r.db.QueryRow(query, email).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.Password, &amp;user.FirstName, &amp;user.LastName,
                &amp;user.PasswordResetToken, &amp;user.ResetTokenExpiresAt,
                &amp;user.CreatedAt, &amp;user.UpdatedAt, &amp;user.DeletedAt)

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                return nil, ErrNotFound
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return user, nil</span>
}

func (r *userRepository) FindByID(id uint) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{}
        query := `
                SELECT id, email, password, first_name, last_name, password_reset_token,
                        reset_token_expires_at, created_at, updated_at, deleted_at
                FROM users
                WHERE id = $1 AND deleted_at IS NULL`

        err := r.db.QueryRow(query, id).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.Password, &amp;user.FirstName, &amp;user.LastName,
                &amp;user.PasswordResetToken, &amp;user.ResetTokenExpiresAt,
                &amp;user.CreatedAt, &amp;user.UpdatedAt, &amp;user.DeletedAt)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, ErrNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (r *userRepository) Update(user *models.User) error <span class="cov1" title="1">{
        user.UpdatedAt = time.Now()

        query := `
                UPDATE users
                SET email = $1, password = $2, first_name = $3, last_name = $4,
                        password_reset_token = $5, reset_token_expires_at = $6, updated_at = $7
                WHERE id = $8 AND deleted_at IS NULL`

        result, err := r.db.Exec(query,
                user.Email, user.Password, user.FirstName, user.LastName,
                user.PasswordResetToken, user.ResetTokenExpiresAt,
                user.UpdatedAt, user.ID)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (r *userRepository) Delete(id uint) error <span class="cov1" title="1">{
        now := time.Now()
        query := `
                UPDATE users
                SET deleted_at = $1
                WHERE id = $2 AND deleted_at IS NULL`

        result, err := r.db.Exec(query, now, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (r *userRepository) FindByResetToken(token string) (*models.User, error) <span class="cov1" title="1">{
        user := &amp;models.User{}
        query := `
                SELECT id, email, password, first_name, last_name, password_reset_token,
                        reset_token_expires_at, created_at, updated_at, deleted_at
                FROM users
                WHERE password_reset_token = $1 AND deleted_at IS NULL`

        err := r.db.QueryRow(query, token).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.Password, &amp;user.FirstName, &amp;user.LastName,
                &amp;user.PasswordResetToken, &amp;user.ResetTokenExpiresAt,
                &amp;user.CreatedAt, &amp;user.UpdatedAt, &amp;user.DeletedAt)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, ErrNotFound
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package services

import (
        "context"
        "errors"
        "time"

        "github.com/redis/go-redis/v9"
)

var (
        ErrAccountLocked = errors.New("account is locked due to too many failed attempts")
)

type AccountLockoutService struct {
        redis         *redis.Client
        maxAttempts   int
        lockDuration  time.Duration
        attemptExpiry time.Duration
}

func NewAccountLockoutService(redis *redis.Client) *AccountLockoutService <span class="cov4" title="4">{
        return &amp;AccountLockoutService{
                redis:         redis,
                maxAttempts:   5,                // Lock after 5 failed attempts
                lockDuration:  15 * time.Minute, // Lock for 15 minutes
                attemptExpiry: 1 * time.Hour,    // Reset attempts after 1 hour
        }
}</span>

// RecordFailedAttempt increments the failed attempt counter for an email
func (s *AccountLockoutService) RecordFailedAttempt(ctx context.Context, email string) error <span class="cov9" title="19">{
        // Check if account is locked
        locked, err := s.IsLocked(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov9" title="19">if locked </span><span class="cov1" title="1">{
                return ErrAccountLocked
        }</span>

        // Increment failed attempts
        <span class="cov8" title="18">attemptsKey := "failed_attempts:" + email
        pipe := s.redis.Pipeline()
        pipe.Incr(ctx, attemptsKey)
        pipe.Expire(ctx, attemptsKey, s.attemptExpiry)
        _, err = pipe.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if account should be locked
        <span class="cov8" title="18">attempts, err := s.redis.Get(ctx, attemptsKey).Int()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="18">if attempts &gt;= s.maxAttempts </span><span class="cov2" title="2">{
                lockKey := "account_locked:" + email
                err = s.redis.Set(ctx, lockKey, true, s.lockDuration).Err()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="18">return nil</span>
}

// IsLocked checks if an account is currently locked
func (s *AccountLockoutService) IsLocked(ctx context.Context, email string) (bool, error) <span class="cov10" title="26">{
        lockKey := "account_locked:" + email
        exists, err := s.redis.Exists(ctx, lockKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov10" title="26">return exists == 1, nil</span>
}

// ResetAttempts resets the failed attempt counter for an email (e.g., after successful login)
func (s *AccountLockoutService) ResetAttempts(ctx context.Context, email string) error <span class="cov2" title="2">{
        attemptsKey := "failed_attempts:" + email
        lockKey := "account_locked:" + email

        pipe := s.redis.Pipeline()
        pipe.Del(ctx, attemptsKey)
        pipe.Del(ctx, lockKey)
        _, err := pipe.Exec(ctx)
        return err
}</span>

// GetRemainingAttempts returns the number of attempts remaining before account lockout
func (s *AccountLockoutService) GetRemainingAttempts(ctx context.Context, email string) (int, error) <span class="cov4" title="4">{
        attemptsKey := "failed_attempts:" + email
        attempts, err := s.redis.Get(ctx, attemptsKey).Int()
        if err == redis.Nil </span><span class="cov2" title="2">{
                return s.maxAttempts, nil
        }</span>
        <span class="cov2" title="2">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov2" title="2">remaining := s.maxAttempts - attempts
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                remaining = 0
        }</span>
        <span class="cov2" title="2">return remaining, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package services

import (
        "EchoAuth/config"
        "EchoAuth/models"
        "EchoAuth/repositories"
        "EchoAuth/utils/validator"
        "context"
        "crypto/rand"
        "encoding/base64"
        "errors"
        "time"

        "github.com/golang-jwt/jwt"
)

var (
        ErrInvalidCredentials = errors.New("invalid email or password")
        ErrUserExists         = errors.New("user already exists")
)

type AuthServiceInterface interface {
        Register(email, password, firstName, lastName string) error
        LoginWithRefresh(email, password, deviceInfo, ip string) (string, string, error)
        Logout(token string) error
        ValidateToken(token string) (*models.TokenClaims, error)
        RefreshToken(refreshToken, deviceInfo, ip string) (string, string, error)
        GetJWTExpiry() time.Duration
        GetUserByEmail(email string) (*models.User, error)
}

type AuthService struct {
        userRepo      repositories.UserRepository
        tokenRepo     repositories.TokenRepositoryInterface
        jwtExpiry     time.Duration
        refreshExpiry time.Duration
        jwtSecret     string
        lockoutSvc    *AccountLockoutService
}

func NewAuthService(userRepo repositories.UserRepository, tokenRepo repositories.TokenRepositoryInterface, cfg *config.Config, lockoutSvc *AccountLockoutService) *AuthService <span class="cov8" title="6">{
        return &amp;AuthService{
                userRepo:      userRepo,
                tokenRepo:     tokenRepo,
                jwtExpiry:     cfg.JWTExpiry,
                refreshExpiry: 30 * 24 * time.Hour, // 30 days
                jwtSecret:     cfg.JWTSecret,
                lockoutSvc:    lockoutSvc,
        }
}</span>

func (s *AuthService) Register(email, password, firstName, lastName string) error <span class="cov10" title="8">{
        // Validate email
        if err := validator.ValidateEmail(email); err != nil </span><span class="cov5" title="3">{
                return err
        }</span>

        // Validate password complexity
        <span class="cov7" title="5">if err := validator.ValidatePassword(password); err != nil </span><span class="cov5" title="3">{
                return err
        }</span>

        // Check if user exists
        <span class="cov4" title="2">existingUser, err := s.userRepo.FindByEmail(email)
        if err != nil &amp;&amp; !errors.Is(err, repositories.ErrNotFound) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="2">if existingUser != nil </span><span class="cov1" title="1">{
                return ErrUserExists
        }</span>

        // Create new user
        <span class="cov1" title="1">user := &amp;models.User{
                Email:     email,
                FirstName: firstName,
                LastName:  lastName,
        }

        // Hash password
        if err := user.HashPassword(password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return s.userRepo.Create(user)</span>
}

func (s *AuthService) Login(ctx context.Context, email, password string) (string, error) <span class="cov5" title="3">{
        // Check if account is locked
        locked, err := s.lockoutSvc.IsLocked(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="3">if locked </span><span class="cov0" title="0">{
                return "", ErrAccountLocked
        }</span>

        // Find user
        <span class="cov5" title="3">user, err := s.userRepo.FindByEmail(email)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, repositories.ErrNotFound) </span><span class="cov1" title="1">{
                        // Record failed attempt even if user doesn't exist
                        _ = s.lockoutSvc.RecordFailedAttempt(ctx, email)
                        return "", ErrInvalidCredentials
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }

        // Check password
        <span class="cov4" title="2">if !user.CheckPassword(password) </span><span class="cov1" title="1">{
                // Record failed attempt
                err = s.lockoutSvc.RecordFailedAttempt(ctx, email)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov1" title="1">return "", ErrInvalidCredentials</span>
        }

        // Reset failed attempts on successful login
        <span class="cov1" title="1">err = s.lockoutSvc.ResetAttempts(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Generate JWT token
        <span class="cov1" title="1">token := jwt.New(jwt.SigningMethodHS256)
        claims := token.Claims.(jwt.MapClaims)
        claims["user_id"] = user.ID
        claims["exp"] = time.Now().Add(time.Hour * 24).Unix()
        claims["iat"] = time.Now().Unix()

        tokenString, err := token.SignedString([]byte(s.jwtSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">return tokenString, nil</span>
}

func (s *AuthService) ValidateToken(tokenString string) (*models.TokenClaims, error) <span class="cov7" title="4">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;models.TokenClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov4" title="2">{
                return []byte(s.jwtSecret), nil
        }</span>)

        <span class="cov7" title="4">if err != nil </span><span class="cov5" title="3">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if claims, ok := token.Claims.(*models.TokenClaims); ok &amp;&amp; token.Valid </span><span class="cov1" title="1">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}

func (s *AuthService) Logout(token string) error <span class="cov0" title="0">{
        // Validate token first
        claims, err := s.ValidateToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Find user to get email
        <span class="cov0" title="0">user, err := s.userRepo.FindByID(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Reset attempts on logout
        <span class="cov0" title="0">return s.lockoutSvc.ResetAttempts(context.Background(), user.Email)</span>
}

func (s *AuthService) generateRefreshToken() (string, error) <span class="cov4" title="2">{
        b := make([]byte, 32)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov4" title="2">return base64.URLEncoding.EncodeToString(b), nil</span>
}

func (s *AuthService) LoginWithRefresh(email, password string, deviceInfo, ip string) (string, string, error) <span class="cov5" title="3">{
        user, err := s.userRepo.FindByEmail(email)
        if err != nil </span><span class="cov1" title="1">{
                return "", "", err
        }</span>

        <span class="cov4" title="2">if !user.CheckPassword(password) </span><span class="cov1" title="1">{
                return "", "", errors.New("invalid credentials")
        }</span>

        // Generate access token
        <span class="cov1" title="1">accessToken, err := s.GenerateToken(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Generate refresh token
        <span class="cov1" title="1">refreshToken, err := s.generateRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Store refresh token
        <span class="cov1" title="1">_, err = s.tokenRepo.CreateRefreshToken(
                user.ID,
                refreshToken,
                time.Now().Add(s.refreshExpiry),
                deviceInfo,
                ip,
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov1" title="1">return accessToken, refreshToken, nil</span>
}

func (s *AuthService) RefreshToken(refreshToken, deviceInfo, ip string) (string, string, error) <span class="cov7" title="4">{
        // Get existing refresh token
        token, err := s.tokenRepo.GetRefreshToken(refreshToken)
        if err != nil </span><span class="cov1" title="1">{
                return "", "", errors.New("invalid refresh token")
        }</span>

        // Validate token
        <span class="cov5" title="3">if !token.IsValid() </span><span class="cov4" title="2">{
                return "", "", errors.New("refresh token is expired or revoked")
        }</span>

        // Generate new tokens
        <span class="cov1" title="1">accessToken, err := s.GenerateToken(token.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov1" title="1">newRefreshToken, err := s.generateRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Rotate refresh token
        <span class="cov1" title="1">_, err = s.tokenRepo.RotateRefreshToken(
                token,
                newRefreshToken,
                time.Now().Add(s.refreshExpiry),
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov1" title="1">return accessToken, newRefreshToken, nil</span>
}

func (s *AuthService) RevokeToken(refreshToken string) error <span class="cov4" title="2">{
        return s.tokenRepo.RevokeRefreshToken(refreshToken)
}</span>

func (s *AuthService) RevokeAllUserTokens(userID uint) error <span class="cov0" title="0">{
        return s.tokenRepo.RevokeAllUserTokens(userID)
}</span>

func (s *AuthService) LogoutWithRefresh(refreshToken string) error <span class="cov0" title="0">{
        return s.RevokeToken(refreshToken)
}</span>

func (s *AuthService) GenerateToken(userID uint) (string, error) <span class="cov4" title="2">{
        token := jwt.New(jwt.SigningMethodHS256)
        claims := token.Claims.(jwt.MapClaims)
        claims["user_id"] = userID
        claims["exp"] = time.Now().Add(s.jwtExpiry).Unix()
        claims["iat"] = time.Now().Unix()

        return token.SignedString([]byte(s.jwtSecret))
}</span>

func (s *AuthService) GetJWTExpiry() time.Duration <span class="cov0" title="0">{
        return s.jwtExpiry
}</span>

func (s *AuthService) GetUserByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        return s.userRepo.FindByEmail(email)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package services

import (
        "fmt"
        "net/smtp"
)

type EmailService interface {
        SendPasswordResetEmail(to, resetToken string) error
        SendVerificationEmail(to, verificationToken string) error
}

type emailServiceImpl struct {
        config SMTPConfig
}

type SMTPConfig struct {
        Host     string
        Port     int
        Username string
        Password string
        From     string
}

func NewEmailService(config SMTPConfig) EmailService <span class="cov1" title="1">{
        return &amp;emailServiceImpl{
                config: config,
        }
}</span>

func (s *emailServiceImpl) SendPasswordResetEmail(to, resetToken string) error <span class="cov1" title="1">{
        subject := "Password Reset Request"
        body := fmt.Sprintf(`
Hello,

You have requested to reset your password. Please use the following token:

%s

If you did not request this, please ignore this email.

Best regards,
Your App Team
`, resetToken)

        return s.sendEmail(to, subject, body)
}</span>

func (s *emailServiceImpl) SendVerificationEmail(to, verificationToken string) error <span class="cov1" title="1">{
        subject := "Verify Your Email"
        body := fmt.Sprintf(`
Hello,

Please verify your email address by using the following token:

%s

Best regards,
Your App Team
`, verificationToken)

        return s.sendEmail(to, subject, body)
}</span>

func (s *emailServiceImpl) sendEmail(to, subject, body string) error <span class="cov10" title="2">{
        addr := fmt.Sprintf("%s:%d", s.config.Host, s.config.Port)
        msg := fmt.Sprintf("From: %s\r\n"+
                "To: %s\r\n"+
                "Subject: %s\r\n"+
                "\r\n"+
                "%s", s.config.From, to, subject, body)

        var auth smtp.Auth
        if s.config.Username != "" </span><span class="cov0" title="0">{
                auth = smtp.PlainAuth("", s.config.Username, s.config.Password, s.config.Host)
        }</span>

        <span class="cov10" title="2">return smtp.SendMail(addr, auth, s.config.From, []string{to}, []byte(msg))</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package services

import (
        "EchoAuth/models"
        "EchoAuth/repositories"
        "EchoAuth/utils/validator"
        "crypto/rand"
        "encoding/hex"
        "errors"
        "log"
        "time"
)

type PasswordResetService struct {
        userRepo     repositories.UserRepository
        emailService EmailService
}

func NewPasswordResetService(userRepo repositories.UserRepository, emailService EmailService) *PasswordResetService <span class="cov6" title="3">{
        return &amp;PasswordResetService{
                userRepo:     userRepo,
                emailService: emailService,
        }
}</span>

// GenerateResetToken creates a reset token for the user with the given email
func (s *PasswordResetService) GenerateResetToken(email string) (string, error) <span class="cov9" title="5">{
        // Validate email format
        if err := validator.ValidateEmail(email); err != nil </span><span class="cov6" title="3">{
                return "", err
        }</span>

        <span class="cov4" title="2">user, err := s.userRepo.FindByEmail(email)
        if err != nil </span><span class="cov1" title="1">{
                return "", errors.New("user not found")
        }</span>

        // Generate random token
        <span class="cov1" title="1">b := make([]byte, 32)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">token := hex.EncodeToString(b)

        // Set token expiration (24 hours from now)
        expiresAt := time.Now().Add(24 * time.Hour)
        user.PasswordResetToken = token
        user.ResetTokenExpiresAt = expiresAt

        if err := s.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Send reset email
        <span class="cov1" title="1">if err := s.emailService.SendPasswordResetEmail(email, token); err != nil </span><span class="cov0" title="0">{
                // Log the error but don't return it to avoid revealing user existence
                log.Printf("Failed to send password reset email: %v", err)
        }</span>

        <span class="cov1" title="1">return token, nil</span>
}

// ValidateResetToken checks if the reset token is valid and not expired
func (s *PasswordResetService) ValidateResetToken(token string) (*models.User, error) <span class="cov10" title="6">{
        if token == "" </span><span class="cov1" title="1">{
                return nil, errors.New("invalid token")
        }</span>

        <span class="cov9" title="5">user, err := s.userRepo.FindByResetToken(token)
        if err != nil </span><span class="cov4" title="2">{
                return nil, errors.New("invalid token")
        }</span>

        <span class="cov6" title="3">if user.ResetTokenExpiresAt.IsZero() || user.ResetTokenExpiresAt.Before(time.Now()) </span><span class="cov1" title="1">{
                return nil, errors.New("token expired")
        }</span>

        <span class="cov4" title="2">return user, nil</span>
}

// ResetPassword changes the user's password and invalidates the reset token
func (s *PasswordResetService) ResetPassword(token, newPassword string) error <span class="cov9" title="5">{
        // Validate new password first
        if err := validator.ValidatePassword(newPassword); err != nil </span><span class="cov6" title="3">{
                return err
        }</span>

        // Then validate token
        <span class="cov4" title="2">user, err := s.ValidateResetToken(token)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">if err := user.HashPassword(newPassword); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Clear reset token
        <span class="cov1" title="1">user.PasswordResetToken = ""
        user.ResetTokenExpiresAt = time.Time{}

        return s.userRepo.Update(user)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
)

type RateLimiter interface {
        Allow(key string) (bool, error)
        Reset(key string) error
}

type RateLimiterConfig struct {
        MaxAttempts int
        Window      time.Duration
}

type redisRateLimiter struct {
        client      *redis.Client
        maxAttempts int
        window      time.Duration
}

func NewRateLimiter(client *redis.Client, config RateLimiterConfig) RateLimiter <span class="cov1" title="1">{
        return &amp;redisRateLimiter{
                client:      client,
                maxAttempts: config.MaxAttempts,
                window:      config.Window,
        }
}</span>

// Allow checks if the action is allowed for the given key
func (r *redisRateLimiter) Allow(key string) (bool, error) <span class="cov10" title="6">{
        ctx := context.Background()
        now := time.Now().Unix()
        windowStart := now - int64(r.window.Seconds())

        // Use Lua script for atomic operation
        script := `
                -- Remove old attempts
                redis.call('ZREMRANGEBYSCORE', KEYS[1], 0, ARGV[1])
                
                -- Count attempts in window
                local count = redis.call('ZCARD', KEYS[1])
                
                -- Check if under limit
                if count &gt;= tonumber(ARGV[3]) then
                        return 0
                end
                
                -- Add new attempt with unique member (timestamp:nanos)
                redis.call('ZADD', KEYS[1], ARGV[2], ARGV[2] .. ':' .. ARGV[5])
                
                -- Set expiration
                redis.call('EXPIRE', KEYS[1], ARGV[4])
                
                return 1
        `

        // Run the script
        result, err := r.client.Eval(ctx, script, []string{key},
                windowStart,             // ARGV[1] - window start
                now,                     // ARGV[2] - current timestamp
                r.maxAttempts,           // ARGV[3] - max attempts
                int(r.window.Seconds()), // ARGV[4] - window in seconds
                time.Now().UnixNano(),   // ARGV[5] - nanoseconds for unique member
        ).Int()

        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to execute rate limit check: %w", err)
        }</span>

        <span class="cov10" title="6">return result == 1, nil</span>
}

// Reset resets the rate limit for the given key
func (r *redisRateLimiter) Reset(key string) error <span class="cov1" title="1">{
        ctx := context.Background()
        return r.client.Del(ctx, key).Err()
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package logger

import (
        "os"
        "time"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

func Init() <span class="cov10" title="3">{
        // Pretty print logs in development
        if os.Getenv("ENV") != "production" </span><span class="cov10" title="3">{
                log.Logger = log.Output(zerolog.ConsoleWriter{
                        Out:        os.Stdout,
                        TimeFormat: time.RFC3339,
                })
        }</span>

        // Set global log level
        <span class="cov10" title="3">level := os.Getenv("LOG_LEVEL")
        switch level </span>{
        case "debug":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.DebugLevel)</span>
        case "info":<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.InfoLevel)</span>
        case "warn":<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.WarnLevel)</span>
        case "error":<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.ErrorLevel)</span>
        default:<span class="cov6" title="2">
                zerolog.SetGlobalLevel(zerolog.InfoLevel)</span>
        }

        // Add timestamp to all logs
        <span class="cov10" title="3">zerolog.TimeFieldFormat = time.RFC3339</span>
}

// GetLogger returns a logger with the given component name
func GetLogger(component string) zerolog.Logger <span class="cov1" title="1">{
        return log.With().Str("component", component).Logger()
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package metrics

import (
        "net/http"
        "strconv"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
        RequestDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "Duration of HTTP requests in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"path", "method", "status_code"},
        )

        DatabaseOperations = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "database_operations_total",
                        Help: "Total number of database operations",
                },
                []string{"operation", "status"},
        )

        AuthenticationAttempts = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "authentication_attempts_total",
                        Help: "Total number of authentication attempts",
                },
                []string{"status"},
        )

        ActiveTokens = prometheus.NewGauge(
                prometheus.GaugeOpts{
                        Name: "active_tokens",
                        Help: "Number of currently active tokens",
                },
        )

        RateLimitHits = prometheus.NewCounter(
                prometheus.CounterOpts{
                        Name: "rate_limit_hits_total",
                        Help: "Total number of rate limit hits",
                },
        )
)

func init() <span class="cov1" title="1">{
        prometheus.MustRegister(RequestDuration)
        prometheus.MustRegister(DatabaseOperations)
        prometheus.MustRegister(AuthenticationAttempts)
        prometheus.MustRegister(ActiveTokens)
        prometheus.MustRegister(RateLimitHits)
}</span>

// RecordRequestDuration is middleware that records the duration of HTTP requests
func RecordRequestDuration(next http.Handler) http.Handler <span class="cov8" title="3">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="3">{
                start := time.Now()
                rec := &amp;statusRecorder{ResponseWriter: w, Status: http.StatusOK}
                next.ServeHTTP(rec, r)
                duration := time.Since(start).Seconds()
                RequestDuration.WithLabelValues(r.URL.Path, r.Method, strconv.Itoa(rec.Status)).Observe(duration)
        }</span>)
}

// statusRecorder wraps http.ResponseWriter to capture status code
type statusRecorder struct {
        http.ResponseWriter
        Status int
}

func (r *statusRecorder) WriteHeader(status int) <span class="cov8" title="3">{
        r.Status = status
        r.ResponseWriter.WriteHeader(status)
}</span>

// RecordDatabaseOperation records a database operation with its status
func RecordDatabaseOperation(operation, status string) <span class="cov10" title="4">{
        DatabaseOperations.WithLabelValues(operation, status).Inc()
}</span>

// RecordAuthenticationAttempt records an authentication attempt
func RecordAuthenticationAttempt(success bool) <span class="cov8" title="3">{
        status := "success"
        if !success </span><span class="cov1" title="1">{
                status = "failure"
        }</span>
        <span class="cov8" title="3">AuthenticationAttempts.WithLabelValues(status).Inc()</span>
}

// RecordActiveTokens sets the current number of active tokens
func RecordActiveTokens(count int) <span class="cov8" title="3">{
        ActiveTokens.Set(float64(count))
}</span>

// RecordRateLimitHit increments the rate limit hits counter
func RecordRateLimitHit() <span class="cov0" title="0">{
        RateLimitHits.Inc()
}</span>

// Handler returns an HTTP handler for the metrics endpoint
func Handler() http.Handler <span class="cov1" title="1">{
        return promhttp.Handler()
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package response

import (
        "encoding/json"
        "net/http"
)

func JSONResponse(w http.ResponseWriter, data interface{}, status int) <span class="cov10" title="6">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(data)
}</span>

func JSONError(w http.ResponseWriter, message string, status int) <span class="cov6" title="3">{
        JSONResponse(w, map[string]string{"error": message}, status)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package validator

import (
        "errors"
        "regexp"
        "strings"
)

var (
        ErrEmailEmpty    = errors.New("email cannot be empty")
        ErrEmailInvalid  = errors.New("email format is invalid")
        ErrEmailTooLong  = errors.New("email is too long")
        ErrDomainInvalid = errors.New("email domain is invalid")
)

// Regular expression for basic email validation
// This regex checks for:
// - At least one character before @
// - @ symbol
// - At least one character for domain
// - At least one dot in domain
// - At least 2 characters after last dot
// - Only allows letters, numbers, dots, hyphens, and underscores
var emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9]\.[a-zA-Z]{2,}$`)

// Maximum length for email address (254 is the practical limit)
const maxEmailLength = 254

// ValidateEmail checks if an email address is valid
func ValidateEmail(email string) error <span class="cov10" title="27">{
        // Check if email is empty
        if email = strings.TrimSpace(email); email == "" </span><span class="cov2" title="2">{
                return ErrEmailEmpty
        }</span>

        // Check email length
        <span class="cov9" title="25">if len(email) &gt; maxEmailLength </span><span class="cov1" title="1">{
                return ErrEmailTooLong
        }</span>

        // Split email into local and domain parts
        <span class="cov9" title="24">parts := strings.Split(email, "@")
        if len(parts) != 2 </span><span class="cov2" title="2">{
                return ErrEmailInvalid
        }</span>

        // Additional domain validation
        <span class="cov9" title="22">domain := parts[1]
        if strings.HasPrefix(domain, ".") || strings.HasSuffix(domain, ".") </span><span class="cov2" title="2">{
                return ErrDomainInvalid
        }</span>

        // Check for consecutive dots in domain
        <span class="cov9" title="20">if strings.Contains(domain, "..") </span><span class="cov1" title="1">{
                return ErrDomainInvalid
        }</span>

        // Check email format using regex
        <span class="cov9" title="19">if !emailRegex.MatchString(email) </span><span class="cov7" title="10">{
                return ErrEmailInvalid
        }</span>

        <span class="cov7" title="9">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package validator

import (
        "errors"
        "strings"
        "unicode"
)

var (
        ErrPasswordTooShort  = errors.New("password must be at least 8 characters long")
        ErrPasswordTooSimple = errors.New("password must contain at least one uppercase letter, one lowercase letter, one number, and one special character")
        ErrPasswordCommon    = errors.New("password is too common or easily guessable")
)

// Common passwords that should be rejected
var commonPasswords = map[string]bool{
        "password123": true,
        "12345678":    true,
        "qwerty123":   true,
        "admin123":    true,
        // Add more common passwords as needed
}

// ValidatePassword checks if a password meets security requirements
func ValidatePassword(password string) error <span class="cov6" title="22">{
        if len(password) &lt; 8 </span><span class="cov2" title="2">{
                return ErrPasswordTooShort
        }</span>

        // Check if password is in common password list first
        <span class="cov6" title="20">if commonPasswords[strings.ToLower(password)] </span><span class="cov2" title="3">{
                return ErrPasswordCommon
        }</span>

        <span class="cov5" title="17">var (
                hasUpper   bool
                hasLower   bool
                hasNumber  bool
                hasSpecial bool
        )

        for _, char := range password </span><span class="cov10" title="211">{
                switch </span>{
                case unicode.IsUpper(char):<span class="cov7" title="48">
                        hasUpper = true</span>
                case unicode.IsLower(char):<span class="cov8" title="94">
                        hasLower = true</span>
                case unicode.IsNumber(char):<span class="cov7" title="41">
                        hasNumber = true</span>
                case unicode.IsPunct(char) || unicode.IsSymbol(char):<span class="cov6" title="26">
                        hasSpecial = true</span>
                }
        }

        <span class="cov5" title="17">if !hasUpper || !hasLower || !hasNumber || !hasSpecial </span><span class="cov5" title="12">{
                return ErrPasswordTooSimple
        }</span>

        <span class="cov3" title="5">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
